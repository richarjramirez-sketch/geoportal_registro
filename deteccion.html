<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Geoportal ‚Äî Detecci√≥n Miner√≠a Ilegal en ANP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Proj4js (WGS84 <-> UTM) para mostrar coordenadas UTM en pantalla -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    body { margin:0; font-family: Arial, sans-serif; background:#0f172a; color:#e5e7eb; }
    header { padding:12px 16px; background:#020617; border-bottom:1px solid #1e293b; }
    main { display:grid; grid-template-columns: 420px 1fr; height:calc(100vh - 50px); }
    aside { padding:14px; background:#020617; overflow:auto; }
    #map { height:100%; }
    h3 { margin:12px 0 6px; font-size:14px; color:#93c5fd; }
    label { font-size:12px; display:block; margin-top:8px; color:#cbd5f5; }
    input, select, textarea {
      width:100%; padding:8px; border-radius:6px;
      border:1px solid #334155; background:#020617; color:#e5e7eb;
    }
    input[readonly]{ background:#0b1220; cursor:not-allowed; color:#dbeafe; }
    input:disabled, textarea:disabled, select:disabled { opacity:0.75; cursor:not-allowed; }
    textarea { resize:vertical; }
    .row2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    button {
      margin-top:10px; padding:8px; width:100%;
      background:#2563eb; border:none; border-radius:6px;
      color:white; font-weight:bold; cursor:pointer;
    }
    button.secondary { background:#0ea5e9; }
    button.tertiary { background:#475569; }
    button:disabled { opacity:0.5; cursor:not-allowed; }
    .msg { margin-top:10px; font-size:12px; padding:8px; border-radius:6px; }
    .ok { background:#064e3b; }
    .err { background:#7f1d1d; }
    .pill {
      display:inline-block; padding:4px 8px; border-radius:999px;
      background:#111827; border:1px solid #334155; font-size:12px;
      color:#e5e7eb; margin-top:8px;
    }
  
  .latlon-hidden{display:none;}

/* === Etiquetas (labels) de Puestos SERNANP: solo texto, sin caja === */
.leaflet-tooltip.puesto-label{
  background: transparent;
  border: none;
  box-shadow: none;
  color: #ffffff;
  font-size: 11px;
  font-weight: bold;
  text-shadow: 0 0 3px #000;
  padding: 0;
}
    .list { margin-top:8px; }
    .item { background:#111827; padding:8px; border-radius:6px; margin-top:8px; border:1px solid #334155; font-size:12px; }
    button.mini { background:#dc2626; padding:4px 8px; width:auto; margin-top:6px; font-size:11px; border-radius:6px; }

</style>
</head>

<body>
<header><b>Geoportal ‚Äî Detecci√≥n de Miner√≠a Ilegal en ANP</b></header>

<main>
  <aside>
    <h3>1) Seleccionar ANP</h3>
    <label>√Årea Natural Protegida</label>
    <select id="anpSelect">
      <option value="">‚Äî Cargando ANP ‚Äî</option>
    </select>

    <h3>2) Detecci√≥n ‚Äì Evento (una sola vez)</h3>
    <label>dete_id</label>
    <input id="deteId" readonly>
    <label>usuario_creacion</label>
    <input id="usuarioCreacion" placeholder="Ej: richar.ramirez">

    <label>fecha_dete</label>
    <input type="date" id="fechaDete">

    <label>fuente_dete</label>
    <select id="fuenteDete">
      <option value="">‚Äî Cargando fuentes ‚Äî</option>
    </select>

    <label>observaci√≥n</label>
    <textarea id="obsDete"></textarea>

    <button id="saveEventoBtn">Guardar evento</button>
    <div class="pill" id="estadoEvento">Estado evento: NO guardado</div>

    <h3>3) Ubicaci√≥n (coordenada / sitio)</h3>
    <p style="font-size:12px;color:#94a3b8; margin:6px 0 10px;">
      ‚Ä¢ Clic en el mapa: seleccionar ubicaci√≥n<br>
      ‚Ä¢ <b>Shift + arrastrar</b>: seleccionar centro de zona
    </p>

    <div class="pill" id="estadoUbicacion">Ubicaci√≥n activa: NO</div>

    <!-- Coordenadas editables: el usuario puede ajustar manualmente lat/lon --><div style="margin-top:0; padding:10px; border:1px solid rgba(148,163,184,.25); border-radius:12px;">
      <div style="font-size:12px; color:#94a3b8; margin-bottom:8px;"><b>Coordenadas UTM (WGS84)</b> ‚Äî ingreso principal (puedes editar)</div>
      

    
<div class="row3">
        <div>
          <label>zona</label>
          <input id="utmZona" placeholder="Ej: 19S">
        </div>
        <div>
          <label>este (m)</label>
          <input id="utmE" inputmode="decimal">
        </div>
        <div>
          <label>norte (m)</label>
          <input id="utmN" inputmode="decimal">
        </div>
      
<div class="row2 latlon-hidden">
      <div>
        <label>latitud (auto)</label>
        <input id="lat" placeholder="Ej: -12.345678">
      </div>
      <div>
        <label>longitud (auto)</label>
        <input id="lng" placeholder="Ej: -69.123456">
      </div>
    </div>
</div>
    </div>

    <button id="saveUbicacionBtn" class="secondary" disabled>Guardar ubicaci√≥n</button>
    <button id="nuevaUbicacionBtn" class="tertiary" disabled>Nueva ubicaci√≥n</button>

    <h3>4) Componentes (N veces por ubicaci√≥n)</h3>

    <label>tipo_comp</label>
    <select id="tipoComp" disabled>
      <option value="">‚Äî Cargando tipos ‚Äî</option>
    </select>

    <label>num_comp</label>
    <input type="number" id="numComp" disabled>

    <label>observaci√≥n componente</label>
    <textarea id="obsPunto" disabled></textarea>

    <button id="addPuntoBtn" class="secondary" disabled>Agregar componente</button>

    <div id="listaComponentes" class="list"><i style="color:#94a3b8">Sin componentes registrados</i></div>

    <button id="finalizarUbicacionBtn" class="tertiary" disabled>Finalizar ubicaci√≥n</button>
    <button id="cerrarEventoBtn" class="tertiary" disabled>Cerrar evento</button>

    <div class="pill" id="contadorPuntos">Ubicaciones: 0 | Componentes: 0</div>
    <div id="msg" class="msg"></div>
  </aside>

  <div id="map"></div>
</main>

<script>
/* ================== SUPABASE ================== */
const SUPABASE_URL = "https://tewrzarmckrztcrmgfjo.supabase.co";
const SUPABASE_KEY =
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRld3J6YXJtY2tyenRjcm1nZmpvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE0ODQ3NTksImV4cCI6MjA3NzA2MDc1OX0.xeQnYEVAV_eIy7zVxFU9W2Fd0xjuF4v-tQjM2REPtCc";
var supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

/* ================== MAPA ================== */
const map = L.map('map', { boxZoom:true, maxZoom: 17 }).setView([-9.2, -75], 5);
L.tileLayer(
  "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
  { maxZoom: 17 }
).addTo(map);

let latlng = null;      // ubicaci√≥n seleccionada (lat/lng)
let marker = null;      // marcador de ubicaci√≥n seleccionada

let anpLayer = null;
let svcLayer = null;

/* ‚úÖ Capa donde se dibujan TODAS las ubicaciones del evento */
const puntosLayer = L.layerGroup().addTo(map);

/* ================== CAPAS ADICIONALES (Departamentos / Puestos SERNANP) ================== */
let departamentosLayer = L.geoJSON(null, {
  interactive: false,
  style: { color:"#22c55e", weight:1.5, fillColor:"#22c55e", fillOpacity:0.08 },
  onEachFeature: (feature, layer) => {
    const p = feature.properties || {};
    const html =
      `<b>Departamento:</b> ${p.departamen ?? '-'}<br>` +
      `<b>C√≥digo:</b> ${p.coddep ?? '-'}<br>` +
      `<b>Capital:</b> ${p.capital ?? '-'}<br>` +
      `<b>Fuente:</b> ${p.fuente ?? '-'}`;
    layer.bindPopup(html);
  }
});

let puestosSernanpLayer = L.layerGroup();

/* Control de capas (conmutador) */
async function loadDepartamentos(){
  const { data, error } = await supabase
    .from("departamentos")
    .select("geom, fuente, departamen, coddep, capital");

  if (error) { msg("Error cargando capa Departamentos: " + error.message, true); return; }

  departamentosLayer.clearLayers();
  (data || []).forEach(r => {
    if (!r?.geom) return;
    const feat = {
      type: "Feature",
      geometry: r.geom,
      properties: {
        fuente: r.fuente,
        departamen: r.departamen,
        coddep: r.coddep,
        capital: r.capital
      }
    };
    departamentosLayer.addData(feat);
  });

  if (!map.hasLayer(departamentosLayer)) departamentosLayer.addTo(map);
  // Zoom inicial EXACTO a l√≠mites de Departamentos (solo una vez)
  if (!window._zoomDepartamentosAplicado) {
    window._zoomDepartamentosAplicado = true;
    const b = departamentosLayer.getBounds();
    if (b && b.isValid && b.isValid()) {
      map.fitBounds(b, { padding: [0, 0], animate: false });
    }
  }

}

async function loadPuestosSernanp(anpCod){
  // Mostrar puestos SERNANP solo cuando se ha seleccionado un ANP
  puestosSernanpLayer.clearLayers();
  if (!anpCod) {
    if (map.hasLayer(puestosSernanpLayer)) map.removeLayer(puestosSernanpLayer);
    return;
  }
  const { data, error } = await supabase
    .from("puestos_sernanp")
    .select("geom, nomb_infra, tipo_infra, anp_cod, infra_cod, obse_infra, acce_infra")
    .eq("anp_cod", anpCod);

  if (error) { msg("Error cargando capa Puestos SERNANP: " + error.message, true); return; }

  puestosSernanpLayer.clearLayers();
  (data || []).forEach(r => {
    const g = r?.geom;
    if (!g || !g.coordinates) return;
    const lng = g.coordinates[0];
    const lat = g.coordinates[1];

    const m = L.circleMarker([lat, lng], {
      radius: 6,
      color: "#f97316",
      weight: 2,
      fillOpacity: 0.8
    });

    // ‚úÖ Etiqueta permanente (solo texto) con el nombre del puesto
    if (r.nomb_infra) {
      m.bindTooltip(r.nomb_infra, {
        permanent: true,
        direction: 'top',
        offset: [0, -8],
        className: 'puesto-label'
      });
    }

    const html =
      `<b>${r.nomb_infra ?? 'Puesto'}</b><br>` +
      `<b>Tipo:</b> ${r.tipo_infra ?? '-'}<br>` +
      `<b>ANP:</b> ${r.anp_cod ?? '-'}<br>` +
      `<b>C√≥digo:</b> ${r.infra_cod ?? '-'}<br>` +
      (r.acce_infra ? `<b>Acceso:</b> ${r.acce_infra}<br>` : '') +
      (r.obse_infra ? `<b>Obs.:</b> ${r.obse_infra}` : '');

    m.bindPopup(html);
    puestosSernanpLayer.addLayer(m);
  });

  if (!map.hasLayer(puestosSernanpLayer)) puestosSernanpLayer.addTo(map);
}

let eventoGuardado = false;
let eventoCerrado = false;

let ubicIdActivo = null;  // ubic_id guardado (ubicaci√≥n activa)
let ubicacionEnProceso = false; // evita doble clic / guardado duplicado

// ‚úÖ Memoria visual de componentes (solo para la ubicaci√≥n activa)
let componentesCache = [];

/* ================== VALIDACI√ìN COORDENADAS ================== */
function parseCoord(v){
  if (v === null || v === undefined) return null;
  const s = String(v).trim().replace(',', '.');
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function coordsValid(latv, lngv){
  return latv !== null && lngv !== null && latv >= -90 && latv <= 90 && lngv >= -180 && lngv <= 180;
}

function formatCoord(n){
  return (typeof n === 'number' && Number.isFinite(n)) ? n.toFixed(6) : '‚Äî';
}

/* ================== UTM (solo visualizaci√≥n) ==================
   - Calcula zona UTM a partir de la longitud
   - Convierte WGS84 (lon/lat) a UTM usando proj4
   - Muestra valores debajo de Lat/Lon
*/
function utmZoneFromLon(lon){
  // Zonas UTM: 1..60
  return Math.floor((lon + 180) / 6) + 1;
}

function updateUTM(latv, lngv){
  const z = document.getElementById('utmZona');
  const e = document.getElementById('utmE');
  const n = document.getElementById('utmN');

  if (!coordsValid(latv, lngv) || typeof proj4 === 'undefined') {
    z.value = ""; e.value = ""; n.value = "";
    return;
  }

  const zone = utmZoneFromLon(lngv);
  const hemi = (latv < 0) ? 'S' : 'N';
  const utmDef = `+proj=utm +zone=${zone} ${latv < 0 ? '+south' : ''} +datum=WGS84 +units=m +no_defs`;

  try {
    const [x, y] = proj4('EPSG:4326', utmDef, [lngv, latv]);
    z.value = `${zone}${hemi}`;
    e.value = Number.isFinite(x) ? Number(x).toFixed(2) : '';
    n.value = Number.isFinite(y) ? Number(y).toFixed(2) : '';
  } catch (err) {
    z.value = ""; e.value = ""; n.value = "";
  }
}

/* ================== MENSAJES ================== */
function msg(t, e=false){
  const m = document.getElementById("msg");
  m.textContent = t;
  m.className = "msg " + (e ? "err" : "ok");
}

/* ================== UI helpers ================== */
function setEstadoEvento() {
  const el = document.getElementById("estadoEvento");
  if (eventoCerrado) el.textContent = "Estado evento: CERRADO";
  else el.textContent = "Estado evento: " + (eventoGuardado ? "GUARDADO" : "NO guardado");

  const bloquearEvento = eventoGuardado || eventoCerrado;
  usuarioCreacion.disabled = bloquearEvento;
  fechaDete.disabled = bloquearEvento;
  fuenteDete.disabled = bloquearEvento;
  obsDete.disabled = bloquearEvento;

  saveEventoBtn.disabled = eventoGuardado || eventoCerrado;
  // Ubicaci√≥n
  const hayEventoActivo = eventoGuardado && !eventoCerrado;
  const latv = parseCoord(lat.value);
  const lngv = parseCoord(lng.value);
  const hayCoordValida = coordsValid(latv, lngv);
  // Actualizar UTM en pantalla (solo visualizaci√≥n)
  updateUTM(latv, lngv);
  // Evita volver a guardar mientras hay ubicaci√≥n activa o guardado en proceso
  saveUbicacionBtn.disabled = !(hayEventoActivo && hayCoordValida) || !!ubicIdActivo || ubicacionEnProceso;
  nuevaUbicacionBtn.disabled = !(hayEventoActivo);

  // Componentes (requiere ubicaci√≥n guardada)
  const hayUbicActiva = hayEventoActivo && !!ubicIdActivo;
  tipoComp.disabled = !hayUbicActiva;
  numComp.disabled = !hayUbicActiva;
  obsPunto.disabled = !hayUbicActiva;
  addPuntoBtn.disabled = !hayUbicActiva;
  finalizarUbicacionBtn.disabled = !hayUbicActiva;

  cerrarEventoBtn.disabled = !(eventoGuardado && !eventoCerrado);

  // Etiqueta estado ubicaci√≥n
  const eu = document.getElementById('estadoUbicacion');
  const hasCoord = hayCoordValida;
  const coordTxt = hasCoord ? `Lat ${formatCoord(latv)} / Lon ${formatCoord(lngv)}` : "Lat ‚Äî / Lon ‚Äî";
  if (ubicIdActivo) eu.textContent = `Ubicaci√≥n activa: ${coordTxt} (ubic_id: ${ubicIdActivo})`;
  else eu.textContent = hasCoord ? `Ubicaci√≥n activa: ${coordTxt}` : "Ubicaci√≥n activa: NO";

  // ‚úÖ Actualiza la lista visual del Punto 4
  renderComponentes();
}

function limpiarPunto() {
  if (marker) { map.removeLayer(marker); marker = null; }
  latlng = null;
  lat.value = "";
  lng.value = "";
  updateUTM(null, null);
  setEstadoEvento();
}

function limpiarCamposComponente(){
  tipoComp.value = "";
  numComp.value = "";
  obsPunto.value = "";
}


function renderComponentes(){
  const cont = document.getElementById("listaComponentes");
  if (!cont) return;

  // Sin ubicaci√≥n activa
  if (!ubicIdActivo) {
    cont.innerHTML = "<i style='color:#94a3b8'>Primero guarda una ubicaci√≥n</i>";
    return;
  }

  if (!componentesCache.length) {
    cont.innerHTML = "<i style='color:#94a3b8'>Sin componentes registrados</i>";
    return;
  }

  cont.innerHTML = componentesCache.map((c, i) => `
    <div class="item">
      <div><b>${c.tipo_desc || '-'}</b>${(c.num_comp !== null && c.num_comp !== undefined) ? ` ¬∑ N¬∞ ${c.num_comp}` : ''}</div>
      ${c.obs ? `<div style="color:#94a3b8; margin-top:4px;">${c.obs}</div>` : ''}
      <button class="mini" data-i="${i}">Quitar</button>
    </div>
  `).join("");

  cont.querySelectorAll("button.mini").forEach(btn=>{
    btn.onclick = ()=>{
      const i = parseInt(btn.dataset.i,10);
      if (!Number.isFinite(i)) return;
      componentesCache.splice(i, 1);
      renderComponentes();
    };
  });
}


function finalizarUbicacion(){
  ubicIdActivo = null;
  // üîì Liberar bloqueo de guardado y permitir marcar nueva ubicaci√≥n
  ubicacionEnProceso = false;

  // ‚úÖ Limpiar memoria visual de componentes
  componentesCache = [];
  renderComponentes();

  limpiarPunto();
  limpiarCamposComponente();
  setEstadoEvento();
}

function setPoint(ll){
  if (eventoCerrado) { msg("El registro ya est√° cerrado.", true); return; }

  latlng = ll;
  lat.value = ll.lat.toFixed(6);
  lng.value = ll.lng.toFixed(6);

  if (marker) map.removeLayer(marker);
  marker = L.marker(ll, { draggable: true }).addTo(map);
  marker.on('dragend', () => {
    const p = marker.getLatLng();
    latlng = p;
    lat.value = p.lat.toFixed(6);
    lng.value = p.lng.toFixed(6);
    setEstadoEvento();
  });

  setEstadoEvento();
}

/* ================== EDICI√ìN MANUAL DE COORDENADAS ==================
   Permite que el usuario ajuste lat/lon en el panel.
   Al cambiar ambos valores v√°lidos, se mueve el marcador.
================================================ */
function syncFromInputsToMap(){
  const latv = parseCoord(lat.value);
  const lngv = parseCoord(lng.value);
  if (!coordsValid(latv, lngv)) {
    // No mostramos error en cada tecla; solo actualizamos estado
    setEstadoEvento();
    return;
  }
  const ll = L.latLng(latv, lngv);
  latlng = ll;
  if (marker) {
    marker.setLatLng(ll);
  } else {
    marker = L.marker(ll, { draggable: true }).addTo(map);
    marker.on('dragend', () => {
      const p = marker.getLatLng();
      latlng = p;
      lat.value = p.lat.toFixed(6);
      lng.value = p.lng.toFixed(6);
      setEstadoEvento();
    });
  }
  setEstadoEvento();
}

/* ================== EDICI√ìN MANUAL: UTM ==================
   - Permite ingresar Zona/Este/Norte en UTM (WGS84) como entrada principal
   - Convierte a Lat/Lon y mueve el marcador
=========================================================== */
let syncingUTM = false;

function parseUTMZone(zStr){
  const s = String(zStr || "").trim().toUpperCase();
  const m = s.match(/^(\d{1,2})\s*([NS])$/);
  if(!m) return null;
  const zone = parseInt(m[1], 10);
  const hemi = m[2];
  if(!(zone >= 1 && zone <= 60)) return null;
  return { zone, hemi };
}

function parseNumberLoose(v){
  // Acepta 487234.12 o 487234,12 o 487,234.12 (se eliminan separadores de miles)
  const s = String(v || "").trim().replace(/\s/g,'').replace(/,/g,'');
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function applyUTMInputsToMap(){
  const z = parseUTMZone(utmZona.value);
  const E = parseNumberLoose(utmE.value);
  const N = parseNumberLoose(utmN.value);
  if(!z || E === null || N === null) { setEstadoEvento(); return; }

  const utmDef = `+proj=utm +zone=${z.zone} ${z.hemi === 'S' ? '+south' : ''} +datum=WGS84 +units=m +no_defs`;

  try {
    const [lngv, latv] = proj4(utmDef, 'EPSG:4326', [E, N]);
    lat.value = Number(latv).toFixed(6);
    lng.value = Number(lngv).toFixed(6);
    // Reusa la l√≥gica existente para mover marcador y recalcular estado/UTM
    syncFromInputsToMap();
  } catch (err) {
    setEstadoEvento();
  }
}

function hookUTMEditing(){
  const handler = () => {
    if(syncingUTM) return;
    syncingUTM = true;
    try { applyUTMInputsToMap(); }
    finally { syncingUTM = false; }
  };

  ['change','blur'].forEach(ev=>{
    utmZona.addEventListener(ev, handler);
    utmE.addEventListener(ev, handler);
    utmN.addEventListener(ev, handler);
  });

  [utmE, utmN].forEach(el=>{
    el.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') handler(); });
  });
}
hookUTMEditing();

/* ================== AUTOGENERAR DETE_ID ================== */
async function genDeteId(anpCod){
  const year = new Date().getFullYear();
  const prefix = `${anpCod}_DET_${year}_`;

  const { data, error } = await supabase
    .from("deteccion_evento")
    .select("dete_id")
    .eq("anp_cod", anpCod)
    .like("dete_id", `${prefix}%`);

  if (error) {
    msg("No se pudo generar dete_id: " + error.message, true);
    return;
  }

  let max = 0;
  const re = new RegExp(`^${anpCod}_DET_${year}_(\\d{3})$`);
  (data || []).forEach(r => {
    const m = String(r.dete_id || "").match(re);
    if (m) max = Math.max(max, parseInt(m[1], 10));
  });

  deteId.value = `${anpCod}_DET_${year}_${String(max + 1).padStart(3, "0")}`;
}


/* ================== CONTADORES ================== */
async function actualizarContadores() {
  const dete_id = deteId.value;
  if (!dete_id) {
    contadorPuntos.textContent = "Ubicaciones: 0 | Componentes: 0";
    return;
  }

  // Ubicaciones
  const u = await supabase
    .from("deteccion_ubicacion")
    .select("*", { count: "exact", head: true })
    .eq("dete_id", dete_id);

  // Componentes (v√≠a view para poder filtrar por dete_id)
  const c = await supabase
    .from("deteccion_view_componente")
    .select("*", { count: "exact", head: true })
    .eq("dete_id", dete_id);

  const nU = u.error ? "?" : (u.count || 0);
  const nC = c.error ? "?" : (c.count || 0);
  contadorPuntos.textContent = `Ubicaciones: ${nU} | Componentes: ${nC}`;
}

/* ================== ‚úÖ CARGAR Y DIBUJAR UBICACIONES DEL EVENTO ================== */
async function cargarUbicacionesEvento() {
  const dete_id = deteId.value;
  puntosLayer.clearLayers();
  if (!dete_id) return;

  const { data, error } = await supabase
    .from("deteccion_view_ubicacion")
    .select("ubic_id, geom, fuente_desc, fecha_dete")
    .eq("dete_id", dete_id);

  if (error) {
    msg("Error cargando ubicaciones: " + error.message, true);
    return;
  }

  (data || []).forEach(u => {
    const g = u.geom;
    if (!g || !g.coordinates) return;
    const lng = g.coordinates[0];
    const lat = g.coordinates[1];

    const m = L.circleMarker([lat, lng], {
      radius: 7,
      color: "#38bdf8",
      weight: 2,
      fillOpacity: 0.65
    });

    // Al abrir popup, trae componentes de esa ubicaci√≥n
    m.on('click', async () => {
      const { data: comps, error: e2 } = await supabase
        .from('deteccion_view_componente')
        .select('tipo_desc, num_comp, obs_componente')
        .eq('ubic_id', u.ubic_id)
        .order('componente_id', { ascending: true });

      let html = `<b>Ubicaci√≥n:</b> ${u.ubic_id}<br>` +
                 `<b>Fuente:</b> ${u.fuente_desc || '-'}<br>` +
                 `<b>Fecha:</b> ${u.fecha_dete || '-'}<hr style="border:0;border-top:1px solid #334155;">`;

      if (e2) {
        html += `<i>Error cargando componentes</i>`;
      } else if (!comps || comps.length === 0) {
        html += `<i>Sin componentes registrados</i>`;
      } else {
        html += `<b>Componentes:</b><br>`;
        html += comps.map(r => {
          const n = (r.num_comp ?? '-')
          const o = (r.obs_componente ? ` ‚Äî ${r.obs_componente}` : '')
          return `‚Ä¢ ${r.tipo_desc || '-'} (N¬∞: ${n})${o}`;
        }).join('<br>');
      }

      m.bindPopup(html).openPopup();
    });

    puntosLayer.addLayer(m);
  });
}

/* ================== CARGAR ANP ================== */
async function loadANP(){
  const { data, error } = await supabase
    .from("v_anp_selector_secure")
    .select("anp_cod, anp_nomb, extent_geojson")
    .order("anp_nomb");

  if (error) { msg("Error cargando ANP: " + error.message, true); return; }

  anpSelect.innerHTML = "<option value=''>‚Äî Seleccione ANP ‚Äî</option>";
  data.forEach(r => {
    const o = document.createElement("option");
    o.value = r.anp_cod;
    o.textContent = r.anp_nomb;
    o.dataset.extent = JSON.stringify(r.extent_geojson);
    anpSelect.appendChild(o);
  });

  msg("ANP cargadas correctamente");
}

/* ================== CARGAR CAT√ÅLOGOS ================== */
async function loadCatalogos(){
  // Fuente detecci√≥n
  const f = await supabase
    .from('dom_fuente_deteccion')
    .select('fuente_cod, fuente_desc')
    .order('fuente_desc');

  if (f.error) {
    msg('Error cargando fuentes: ' + f.error.message, true);
  } else {
    fuenteDete.innerHTML = "<option value=''>‚Äî Seleccione ‚Äî</option>";
    (f.data || []).forEach(r => {
      const o = document.createElement('option');
      o.value = r.fuente_cod;
      o.textContent = r.fuente_desc;
      fuenteDete.appendChild(o);
    });
  }

  // Tipos componente
  const t = await supabase
    .from('dom_tipo_componente')
    .select('tipo_cod, tipo_desc')
    .order('tipo_desc');

  if (t.error) {
    msg('Error cargando tipos de componente: ' + t.error.message, true);
  } else {
    tipoComp.innerHTML = "<option value=''>‚Äî Seleccione ‚Äî</option>";
    (t.data || []).forEach(r => {
      const o = document.createElement('option');
      o.value = r.tipo_cod;
      o.textContent = r.tipo_desc;
      tipoComp.appendChild(o);
    });
  }
}

/* ================== AL CAMBIAR ANP ================== */
anpSelect.addEventListener("change", async (e) => {
  const opt = e.target.selectedOptions[0];
  if (!opt) return;

  const anpCod = opt.value;
  // Limpiar capas previas
  if (anpLayer) { map.removeLayer(anpLayer); anpLayer = null; }
  if (svcLayer) { map.removeLayer(svcLayer); svcLayer = null; }

  // Limpiar puestos al cambiar de ANP
  puestosSernanpLayer.clearLayers();
  if (map.hasLayer(puestosSernanpLayer)) map.removeLayer(puestosSernanpLayer);

  // Reset estados
  eventoGuardado = false;
  eventoCerrado = false;
  ubicIdActivo = null;
  setEstadoEvento();
  limpiarPunto();

  // Limpiar ubicaciones del mapa
  puntosLayer.clearLayers();
  contadorPuntos.textContent = "Ubicaciones: 0 | Componentes: 0";

  if (!anpCod) { await loadPuestosSernanp(null); return; }

  await genDeteId(anpCod);

  // ‚úÖ Cargar puestos SERNANP solo para el ANP seleccionado
  await loadPuestosSernanp(anpCod);

  // ANP borde
  const anp = await supabase
    .from("anp_mineria_ilegal")
    .select("geom")
    .eq("anp_cod", anpCod)
    .single();

  if (anp.data?.geom) {
    anpLayer = L.geoJSON(anp.data.geom, { style:{ color:"#00ffff", weight:2, fill:false } }).addTo(map);
      // Zoom exacto al borde del ANP
    map.fitBounds(anpLayer.getBounds(), { paddingTopLeft: [-10, -10], paddingBottomRight: [-10, -10], maxZoom: 15 });
}

  // Sectorizaci√≥n borde
  const svc = await supabase
    .from("sectorizacion_vigilancia")
    .select("geom")
    .eq("anp_cod", anpCod);

  if (svc.data?.length) {
    svcLayer = L.geoJSON(svc.data.map(x => x.geom), { style:{ color:"#ffd400", weight:2, fill:false } }).addTo(map);
  }

  await actualizarContadores();
  await cargarUbicacionesEvento();
});

/* ================== MAP EVENTS ================== */
map.on("click", e => {
  // ‚úÖ Ajuste fino: si el evento est√° cerrado, el mapa queda en modo "solo visual"
  // (no se intenta registrar/editar punto y no se muestra el mensaje de bloqueo)
  if (eventoCerrado) return;

  // üö´ Evitar marcar otra ubicaci√≥n mientras haya una ubicaci√≥n activa o en proceso de guardado
  if (ubicIdActivo || ubicacionEnProceso) {
    msg("‚ö†Ô∏è Finalice la ubicaci√≥n actual antes de marcar otra.", true);
    return;
  }
  setPoint(e.latlng);
});

map.on("boxzoomend", e => {
  // ‚úÖ Ajuste fino: si el evento est√° cerrado, el mapa queda en modo "solo visual"
  if (eventoCerrado) return;

  // üö´ Evitar marcar otra ubicaci√≥n mientras haya una ubicaci√≥n activa o en proceso de guardado
  if (ubicIdActivo || ubicacionEnProceso) {
    msg("‚ö†Ô∏è Finalice la ubicaci√≥n actual antes de marcar otra.", true);
    return;
  }
  setPoint(e.boxZoomBounds.getCenter());
});

/* ================== EDICI√ìN MANUAL: LAT/LON ==================
   - Permite ajustar coordenadas en el panel (Punto 3)
   - Si ambas son v√°lidas, mueve el marcador
================================================ */
lat.addEventListener('change', syncFromInputsToMap);
lng.addEventListener('change', syncFromInputsToMap);
lat.addEventListener('blur', syncFromInputsToMap);
lng.addEventListener('blur', syncFromInputsToMap);
lat.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') syncFromInputsToMap(); });
lng.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') syncFromInputsToMap(); });

/* ================== GUARDAR EVENTO ================== */
saveEventoBtn.onclick = async () => {
  const dete_id = deteId.value;
  const anp_cod = anpSelect.value;

  if (!anp_cod) { msg("Seleccione un ANP", true); return; }
  if (!dete_id) { msg("No se pudo generar dete_id", true); return; }

  const payloadEvento = {
    dete_id,
    anp_cod,
    usuario_creacion: usuarioCreacion.value || null,
    fecha_dete: fechaDete.value || null,
    fuente_dete: fuenteDete.value || null,
    obs_dete: obsDete.value || null
  };

  const ev = await supabase.from("deteccion_evento").insert(payloadEvento);

  if (ev.error && ev.error.code !== "23505") {
    msg("Error evento: " + ev.error.message, true);
    return;
  }

  eventoGuardado = true;
  setEstadoEvento();
  msg("‚úÖ Evento guardado. Ahora seleccione una ubicaci√≥n en el mapa y gu√°rdela.");
};

/* ================== GUARDAR UBICACI√ìN ================== */
saveUbicacionBtn.onclick = async () => {
  const dete_id = deteId.value;

  // üîí Evitar doble clic y registros duplicados
  if (ubicacionEnProceso) {
    msg("‚ö†Ô∏è Ya se est√° guardando esta ubicaci√≥n.", true);
    return;
  }

  if (!eventoGuardado) { msg("Primero guarde el evento.", true); return; }
  if (eventoCerrado) { msg("El evento ya fue cerrado.", true); return; }
  if (!latlng) { msg("Seleccione una ubicaci√≥n (clic o zona).", true); return; }


  // Bloquear UI mientras se guarda
  ubicacionEnProceso = true;
  saveUbicacionBtn.disabled = true;

  const ins = await supabase
    .from('deteccion_ubicacion')
    .insert({
      dete_id,
      geom: `SRID=4326;POINT(${latlng.lng} ${latlng.lat})`,
      latitud: latlng.lat,
      longitud: latlng.lng
    })
    .select('ubic_id')
    .single();

  if (ins.error) {
    // üîì Liberar bloqueo si falla el guardado
    ubicacionEnProceso = false;
    setEstadoEvento();
    msg("Error guardando ubicaci√≥n: " + ins.error.message, true);
    return;
  }

  ubicIdActivo = ins.data.ubic_id;

  // ‚úÖ Nueva ubicaci√≥n: reinicia la lista visual de componentes
  componentesCache = [];
  renderComponentes();

  setEstadoEvento();
  msg(`‚úÖ Ubicaci√≥n guardada (ID: ${ubicIdActivo}). Ahora agregue componentes.`);
  await actualizarContadores();
  await cargarUbicacionesEvento();
};

/* ================== NUEVA UBICACI√ìN (limpia selecci√≥n) ================== */
nuevaUbicacionBtn.onclick = () => {
  if (!eventoGuardado) { msg("Primero guarde el evento.", true); return; }
  if (eventoCerrado) { msg("El evento ya fue cerrado.", true); return; }
  finalizarUbicacion();
  msg("Seleccione una nueva ubicaci√≥n en el mapa.");
};

/* ================== AGREGAR COMPONENTE (N veces por ubicaci√≥n) ================== */
addPuntoBtn.onclick = async () => {
  if (!eventoGuardado) { msg("Primero guarde el evento.", true); return; }
  if (eventoCerrado) { msg("El evento ya fue cerrado.", true); return; }
  if (!ubicIdActivo) { msg("Primero guarde una ubicaci√≥n.", true); return; }
  if (!tipoComp.value) { msg("Seleccione el tipo de componente.", true); return; }

  const payload = {
    ubic_id: ubicIdActivo,
    tipo_comp: tipoComp.value,
    num_comp: (numComp.value === "" ? null : Number(numComp.value)),
    obs_componente: obsPunto.value || null
  };

  const r = await supabase.from('deteccion_componente').insert(payload);
  if (r.error) { msg("Error componente: " + r.error.message, true); return; }

  // ‚úÖ Actualizaci√≥n visual inmediata (Punto 4)
  componentesCache.push({
    tipo_desc: (tipoComp.options[tipoComp.selectedIndex]?.text || tipoComp.value),
    num_comp: (numComp.value === "" ? null : Number(numComp.value)),
    obs: (obsPunto.value || null)
  });
  renderComponentes();

  msg("‚úÖ Componente agregado a la ubicaci√≥n.");
  limpiarCamposComponente();
  await actualizarContadores();
};

/* ================== FINALIZAR UBICACI√ìN ================== */
finalizarUbicacionBtn.onclick = () => {
  if (!ubicIdActivo) { msg("No hay ubicaci√≥n activa.", true); return; }
  finalizarUbicacion();
  msg("‚úÖ Ubicaci√≥n finalizada. Puede registrar otra ubicaci√≥n.");
};

/* ================== CERRAR REGISTRO ================== */
cerrarEventoBtn.onclick = () => {
  if (!eventoGuardado) { msg("Primero debe guardar el evento.", true); return; }
  eventoCerrado = true;
  ubicIdActivo = null;
  setEstadoEvento();
  msg("‚úÖ Evento cerrado. Las ubicaciones quedan visibles.");
};

/* ================== MAGIC LINK: SET ANP DESDE INDEX ================== */
let __pendingAccess = null;

function applyAccessFromIndex(access){
  if(!access || !access.anp_cod) return;

  const anpCod = access.anp_cod;
  const role = access.role || 'user';

  if (!anpSelect || anpSelect.options.length <= 1) {
    __pendingAccess = access;
    return;
  }

  anpSelect.value = anpCod;

  if (anpSelect.value !== anpCod) {
    __pendingAccess = access;
    return;
  }

  if (role !== 'admin') {
    anpSelect.disabled = true;
  }

  anpSelect.dispatchEvent(new Event('change', { bubbles:true }));
  __pendingAccess = null;
}

window.addEventListener('message', (ev) => {
  const d = ev.data || {};
  if (d.type === 'set_anp') {
    applyAccessFromIndex({ role: d.role, anp_cod: d.anp_cod });
  }
});

// Hook seguro para loadANP()
const __loadANP_original = loadANP;
loadANP = async function(){
  await __loadANP_original();
  if (__pendingAccess) applyAccessFromIndex(__pendingAccess);
};

/* INIT */
setEstadoEvento();
loadCatalogos();
loadANP();
loadDepartamentos();
</script>
</body>
</html>
